<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<script src="https://cdn.jsdelivr.net/gh/orstavik/parse@latest/parse.js"></script>
<script src="../../MonkeyPatch/MonkeyPatch.js"></script>
<script src="../constructionFrame.js"></script>
<script>
  (function (addEventListener, removeEventListener) {

    const lastSeen = new WeakMap();
    const listeners = new WeakMap();

    function callChildChanged(el, nodes) {
      lastSeen.set(el, nodes);
      try {
        el.childChangedCallback(nodes);
      } catch (error) {
        window.dispatchEvent(new ErrorEvent('error', {error}));
      }
    }

    function getSlotsAndFlattenChildren(el) {
      const nodes = [];
      const slots = [];
      for (let n of el.childNodes) {
        if (n instanceof HTMLSlotElement) {
          slots.push(n);
          nodes.push(...n.assignedNodes({flatten: true}));
        } else
          nodes.push(n);
      }
      return {nodes, slots};
    }

    function updateSlotchangeListener(el, slots) {
      const previousSlotChangeListener = listeners.get(el);
      if ((previousSlotChangeListener && !slots.length)) {
        removeEventListener.call(el, 'slotchange', listeners.get(el), true);
        listeners.delete(el);
      } else if (!previousSlotChangeListener && slots.length) {
        let listener = checkChildChangedFromEvent.bind(el);
        listeners.set(el, listener);
        addEventListener.call(el, 'slotchange', listener, true);
      } else {
        //nothing to see
      }
    }

    function arraysAreTheSame(a, b) {
      return a.length === b?.length && a.every((n, i) => n === b[i]);
    }

    function setupChildChanged(el) {
      MO.observe(el, {childList: true});
      const {nodes, slots} = getSlotsAndFlattenChildren(el);
      updateSlotchangeListener(el, slots);
      callChildChanged(el, nodes);
    }

    function checkChildChanged(el) {
      // debugger
      const {nodes, slots} = getSlotsAndFlattenChildren(el);
      const previousNodes = lastSeen.get(el);
      if (arraysAreTheSame(nodes, previousNodes))
        return;
      updateSlotchangeListener(el, slots);
      callChildChanged(el, nodes);
    }

    function checkChildChangedFromEvent(e) {
      for (let el of e.composedPath()) {
        if (el instanceof HTMLSlotElement)
          continue;
        if (el === this)
          checkChildChanged(this);
        return;   //slotchangeNipSlip
      }
    }

    function checkChildChangedFromMO(mrs) {
      mrs.map(mr => mr.target).filter((el, i, ar) => ar.indexOf(el) === i).forEach(checkChildChanged);
    }

    const MO = new MutationObserver(checkChildChangedFromMO);
    ElementObserver.complete( (frame, el) => el.childChangedCallback && setupChildChanged(el));
  })(addEventListener, removeEventListener);

</script>
<script>
  class FramedOrderedList extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({mode: 'open', slotAssignment: 'manual'});
      this.shadowRoot.innerHTML = `<ol><slot></slot></ol>`
      console.log("constructor frame");
    }

    childChangedCallback(what) {
      console.log(this.tagName);
      console.log(what);
      this.shadowRoot.querySelector('slot').assign(...this.childNodes);
    }
  }

  customElements.define("frame-ol", FramedOrderedList);

  class FrameFramedOrderedList extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({mode: 'open', slotAssignment: 'manual'});
      this.shadowRoot.innerHTML = `<frame-ol><slot></slot></frame-ol>`
      console.log("constructor frame frame");
    }

    childChangedCallback(what) {
      console.log(this.tagName);
      console.log(what);
      this.shadowRoot.querySelector('slot').assign(...this.childNodes);
    }
  }

  customElements.define("frame-frame-ol", FrameFramedOrderedList);
</script>
<frame-ol a>
  <li>hello</li>
  <li>world</li>
  <li>bob</li>
</frame-ol>
<frame-frame-ol a>
  <li>hello</li>
  <li>world</li>
  <li>bob</li>
</frame-frame-ol>
</body>
</html>